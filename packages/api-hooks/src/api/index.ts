/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * StakeKit
 * StakeKit API documentation
 * OpenAPI spec version: 1.0
 */
import { useQuery, useMutation } from '@tanstack/react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from '@tanstack/react-query';
import type {
  YieldOpportunityDto,
  ValidatorDto,
  StakeDto,
  StakeRequestDto,
  PendingActionRequestDto,
  YieldBalanceDto,
  YieldBalanceRequestDto,
  YieldBalancesWithIntegrationIdDto,
  YieldBalanceWithIntegrationIdRequestDto,
  StakeV2YieldOpportunities200,
  StakeV2YieldOpportunitiesParams,
  TransactionDto,
  ConstructTransactionRequestDto,
  SubmitResponseDto,
  SubmitRequestDto,
  SubmitHashRequestDto,
  TransactionStatusResponseDto,
  GasForNetworkResponseDto,
  PriceResponseDto,
  PriceRequestDto,
  BalanceResponseDto,
  BalancesRequestDto,
} from './schemas';
import { api } from '../api-client';
import { customQueryOptions } from '../query-options';

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * Returns the available yield opportunities (staking, lending, vaults, etc) and associated configuration
 * @summary Get yield opportunities
 */
export const stakeYieldOpportunities = (signal?: AbortSignal) => {
  return api<YieldOpportunityDto[]>({
    url: `/v1/stake/opportunities`,
    method: 'get',
    signal,
  });
};

export const getStakeYieldOpportunitiesQueryKey = () =>
  [`/v1/stake/opportunities`] as const;

export const useStakeYieldOpportunitiesQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeYieldOpportunities>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof stakeYieldOpportunities>>,
    TError,
    TData
  >;
}): UseQueryOptions<
  Awaited<ReturnType<typeof stakeYieldOpportunities>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStakeYieldOpportunitiesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeYieldOpportunities>>
  > = ({ signal }) => stakeYieldOpportunities(signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeYieldOpportunitiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeYieldOpportunities>>
>;
export type StakeYieldOpportunitiesQueryError = unknown;

/**
 * @summary Get yield opportunities
 */
export const useStakeYieldOpportunities = <
  TData = Awaited<ReturnType<typeof stakeYieldOpportunities>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof stakeYieldOpportunities>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeYieldOpportunitiesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a yield opportunity
 * @summary Get yield opportunity
 */
export const stakeYieldOpportunity = (
  integrationId: string,
  signal?: AbortSignal,
) => {
  return api<YieldOpportunityDto>({
    url: `/v1/stake/opportunities/${integrationId}`,
    method: 'get',
    signal,
  });
};

export const getStakeYieldOpportunityQueryKey = (integrationId: string) =>
  [`/v1/stake/opportunities/${integrationId}`] as const;

export const useStakeYieldOpportunityQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeYieldOpportunity>>,
  TError = unknown,
>(
  integrationId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeYieldOpportunity>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof stakeYieldOpportunity>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStakeYieldOpportunityQueryKey(integrationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeYieldOpportunity>>
  > = ({ signal }) => stakeYieldOpportunity(integrationId, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeYieldOpportunityQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeYieldOpportunity>>
>;
export type StakeYieldOpportunityQueryError = unknown;

/**
 * @summary Get yield opportunity
 */
export const useStakeYieldOpportunity = <
  TData = Awaited<ReturnType<typeof stakeYieldOpportunity>>,
  TError = unknown,
>(
  integrationId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeYieldOpportunity>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeYieldOpportunityQueryOptions(
    integrationId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a list of available validators to specify when providing a `validatorAddress` property.
 * @summary Get validators
 */
export const stakeGetValidators = (
  integrationId: string,
  signal?: AbortSignal,
) => {
  return api<ValidatorDto[]>({
    url: `/v1/stake/validators/${integrationId}`,
    method: 'get',
    signal,
  });
};

export const getStakeGetValidatorsQueryKey = (integrationId: string) =>
  [`/v1/stake/validators/${integrationId}`] as const;

export const useStakeGetValidatorsQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeGetValidators>>,
  TError = unknown,
>(
  integrationId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetValidators>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof stakeGetValidators>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStakeGetValidatorsQueryKey(integrationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeGetValidators>>
  > = ({ signal }) => stakeGetValidators(integrationId, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeGetValidatorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeGetValidators>>
>;
export type StakeGetValidatorsQueryError = unknown;

/**
 * @summary Get validators
 */
export const useStakeGetValidators = <
  TData = Awaited<ReturnType<typeof stakeGetValidators>>,
  TError = unknown,
>(
  integrationId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetValidators>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeGetValidatorsQueryOptions(
    integrationId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a stake session with associated transactions
 * @summary Get stake session
 */
export const stakeGetStakeSession = (stakeId: string, signal?: AbortSignal) => {
  return api<StakeDto>({ url: `/v1/stake/${stakeId}`, method: 'get', signal });
};

export const getStakeGetStakeSessionQueryKey = (stakeId: string) =>
  [`/v1/stake/${stakeId}`] as const;

export const useStakeGetStakeSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeGetStakeSession>>,
  TError = unknown,
>(
  stakeId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetStakeSession>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof stakeGetStakeSession>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStakeGetStakeSessionQueryKey(stakeId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeGetStakeSession>>
  > = ({ signal }) => stakeGetStakeSession(stakeId, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeGetStakeSessionQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeGetStakeSession>>
>;
export type StakeGetStakeSessionQueryError = unknown;

/**
 * @summary Get stake session
 */
export const useStakeGetStakeSession = <
  TData = Awaited<ReturnType<typeof stakeGetStakeSession>>,
  TError = unknown,
>(
  stakeId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetStakeSession>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeGetStakeSessionQueryOptions(stakeId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get the transactions necessary to enter a yield bearing position
 * @summary Create "enter" stake session
 */
export const stakeEnter = (stakeRequestDto: StakeRequestDto) => {
  return api<StakeDto>({
    url: `/v1/stake/enter`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: stakeRequestDto,
  });
};

export const useStakeEnterMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeEnter>>,
    TError,
    { data: StakeRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stakeEnter>>,
  TError,
  { data: StakeRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stakeEnter>>,
    { data: StakeRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return stakeEnter(data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type StakeEnterMutationResult = NonNullable<
  Awaited<ReturnType<typeof stakeEnter>>
>;
export type StakeEnterMutationBody = StakeRequestDto;
export type StakeEnterMutationError = unknown;

/**
 * @summary Create "enter" stake session
 */
export const useStakeEnter = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeEnter>>,
    TError,
    { data: StakeRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useStakeEnterMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the transactions necessary to exit a yield bearing position
 * @summary Create "exit" stake session
 */
export const stakeExit = (stakeRequestDto: StakeRequestDto) => {
  return api<StakeDto>({
    url: `/v1/stake/exit`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: stakeRequestDto,
  });
};

export const useStakeExitMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeExit>>,
    TError,
    { data: StakeRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stakeExit>>,
  TError,
  { data: StakeRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stakeExit>>,
    { data: StakeRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return stakeExit(data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type StakeExitMutationResult = NonNullable<
  Awaited<ReturnType<typeof stakeExit>>
>;
export type StakeExitMutationBody = StakeRequestDto;
export type StakeExitMutationError = unknown;

/**
 * @summary Create "exit" stake session
 */
export const useStakeExit = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeExit>>,
    TError,
    { data: StakeRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useStakeExitMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the transactions to apply a pending action
 * @summary Create "pending action" stake session
 */
export const stakePendingActions = (
  pendingActionRequestDto: PendingActionRequestDto,
) => {
  return api<StakeDto>({
    url: `/v1/stake/pending_action`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: pendingActionRequestDto,
  });
};

export const useStakePendingActionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakePendingActions>>,
    TError,
    { data: PendingActionRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stakePendingActions>>,
  TError,
  { data: PendingActionRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stakePendingActions>>,
    { data: PendingActionRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return stakePendingActions(data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type StakePendingActionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof stakePendingActions>>
>;
export type StakePendingActionsMutationBody = PendingActionRequestDto;
export type StakePendingActionsMutationError = unknown;

/**
 * @summary Create "pending action" stake session
 */
export const useStakePendingActions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakePendingActions>>,
    TError,
    { data: PendingActionRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useStakePendingActionsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Given addresses, returns the available, deposited balance, pending actions and associated configuration for any yield opportunity
 * @summary Get staked balances
 */
export const stakeGetSingleIntegrationBalances = (
  integrationId: string,
  yieldBalanceRequestDto: YieldBalanceRequestDto,
) => {
  return api<YieldBalanceDto[]>({
    url: `/v1/stake/balances/${integrationId}`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: yieldBalanceRequestDto,
  });
};

export const useStakeGetSingleIntegrationBalancesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeGetSingleIntegrationBalances>>,
    TError,
    { integrationId: string; data: YieldBalanceRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stakeGetSingleIntegrationBalances>>,
  TError,
  { integrationId: string; data: YieldBalanceRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stakeGetSingleIntegrationBalances>>,
    { integrationId: string; data: YieldBalanceRequestDto }
  > = (props) => {
    const { integrationId, data } = props ?? {};

    return stakeGetSingleIntegrationBalances(integrationId, data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type StakeGetSingleIntegrationBalancesMutationResult = NonNullable<
  Awaited<ReturnType<typeof stakeGetSingleIntegrationBalances>>
>;
export type StakeGetSingleIntegrationBalancesMutationBody =
  YieldBalanceRequestDto;
export type StakeGetSingleIntegrationBalancesMutationError = unknown;

/**
 * @summary Get staked balances
 */
export const useStakeGetSingleIntegrationBalances = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stakeGetSingleIntegrationBalances>>,
    TError,
    { integrationId: string; data: YieldBalanceRequestDto },
    TContext
  >;
}) => {
  const mutationOptions =
    useStakeGetSingleIntegrationBalancesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Given addresses and integration ids, returns respective balances and configuration.
 * @summary Get staked balances for multiple yield opportunities
 */
export const stakeGetMultipleIntegrationBalances = (
  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],
) => {
  return api<YieldBalancesWithIntegrationIdDto[]>({
    url: `/v1/stake/balances`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: yieldBalanceWithIntegrationIdRequestDto,
  });
};

export const getStakeGetMultipleIntegrationBalancesQueryKey = (
  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],
) => [`/v1/stake/balances`, yieldBalanceWithIntegrationIdRequestDto] as const;

export const useStakeGetMultipleIntegrationBalancesQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>,
  TError = unknown,
>(
  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getStakeGetMultipleIntegrationBalancesQueryKey(
      yieldBalanceWithIntegrationIdRequestDto,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>
  > = () =>
    stakeGetMultipleIntegrationBalances(
      yieldBalanceWithIntegrationIdRequestDto,
    );

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeGetMultipleIntegrationBalancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>
>;
export type StakeGetMultipleIntegrationBalancesQueryError = unknown;

/**
 * @summary Get staked balances for multiple yield opportunities
 */
export const useStakeGetMultipleIntegrationBalances = <
  TData = Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>,
  TError = unknown,
>(
  yieldBalanceWithIntegrationIdRequestDto: YieldBalanceWithIntegrationIdRequestDto[],
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeGetMultipleIntegrationBalances>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeGetMultipleIntegrationBalancesQueryOptions(
    yieldBalanceWithIntegrationIdRequestDto,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the available yield opportunities (staking, lending, vaults, etc) and associated configuration
 * @summary Get yield opportunities
 */
export const stakeV2YieldOpportunities = (
  params?: StakeV2YieldOpportunitiesParams,
  signal?: AbortSignal,
) => {
  return api<StakeV2YieldOpportunities200>({
    url: `/v2/stake/opportunities`,
    method: 'get',
    params,
    signal,
  });
};

export const getStakeV2YieldOpportunitiesQueryKey = (
  params?: StakeV2YieldOpportunitiesParams,
) => [`/v2/stake/opportunities`, ...(params ? [params] : [])] as const;

export const useStakeV2YieldOpportunitiesQueryOptions = <
  TData = Awaited<ReturnType<typeof stakeV2YieldOpportunities>>,
  TError = unknown,
>(
  params?: StakeV2YieldOpportunitiesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeV2YieldOpportunities>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof stakeV2YieldOpportunities>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStakeV2YieldOpportunitiesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stakeV2YieldOpportunities>>
  > = ({ signal }) => stakeV2YieldOpportunities(params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type StakeV2YieldOpportunitiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof stakeV2YieldOpportunities>>
>;
export type StakeV2YieldOpportunitiesQueryError = unknown;

/**
 * @summary Get yield opportunities
 */
export const useStakeV2YieldOpportunities = <
  TData = Awaited<ReturnType<typeof stakeV2YieldOpportunities>>,
  TError = unknown,
>(
  params?: StakeV2YieldOpportunitiesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stakeV2YieldOpportunities>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useStakeV2YieldOpportunitiesQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a transaction
 * @summary Get transaction
 */
export const transactionGetTransaction = (
  transactionId: string,
  signal?: AbortSignal,
) => {
  return api<TransactionDto>({
    url: `/v1/transaction/${transactionId}`,
    method: 'get',
    signal,
  });
};

export const getTransactionGetTransactionQueryKey = (transactionId: string) =>
  [`/v1/transaction/${transactionId}`] as const;

export const useTransactionGetTransactionQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionGetTransaction>>,
  TError = unknown,
>(
  transactionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetTransaction>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof transactionGetTransaction>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTransactionGetTransactionQueryKey(transactionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionGetTransaction>>
  > = ({ signal }) => transactionGetTransaction(transactionId, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type TransactionGetTransactionQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionGetTransaction>>
>;
export type TransactionGetTransactionQueryError = unknown;

/**
 * @summary Get transaction
 */
export const useTransactionGetTransaction = <
  TData = Awaited<ReturnType<typeof transactionGetTransaction>>,
  TError = unknown,
>(
  transactionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetTransaction>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTransactionGetTransactionQueryOptions(
    transactionId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Constructs an unsigned transaction given a transaction id and optional gas parameters
 * @summary Construct transaction
 */
export const transactionConstruct = (
  transactionId: string,
  constructTransactionRequestDto: ConstructTransactionRequestDto,
) => {
  return api<TransactionDto>({
    url: `/v1/transaction/${transactionId}`,
    method: 'patch',
    headers: { 'Content-Type': 'application/json' },
    data: constructTransactionRequestDto,
  });
};

export const useTransactionConstructMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionConstruct>>,
    TError,
    { transactionId: string; data: ConstructTransactionRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof transactionConstruct>>,
  TError,
  { transactionId: string; data: ConstructTransactionRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transactionConstruct>>,
    { transactionId: string; data: ConstructTransactionRequestDto }
  > = (props) => {
    const { transactionId, data } = props ?? {};

    return transactionConstruct(transactionId, data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type TransactionConstructMutationResult = NonNullable<
  Awaited<ReturnType<typeof transactionConstruct>>
>;
export type TransactionConstructMutationBody = ConstructTransactionRequestDto;
export type TransactionConstructMutationError = unknown;

/**
 * @summary Construct transaction
 */
export const useTransactionConstruct = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionConstruct>>,
    TError,
    { transactionId: string; data: ConstructTransactionRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useTransactionConstructMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Submits the signed transactions for broadcasting
 * @summary Submit transaction
 */
export const transactionSubmit = (
  transactionId: string,
  submitRequestDto: SubmitRequestDto,
) => {
  return api<SubmitResponseDto>({
    url: `/v1/transaction/${transactionId}/submit`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: submitRequestDto,
  });
};

export const useTransactionSubmitMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionSubmit>>,
    TError,
    { transactionId: string; data: SubmitRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof transactionSubmit>>,
  TError,
  { transactionId: string; data: SubmitRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transactionSubmit>>,
    { transactionId: string; data: SubmitRequestDto }
  > = (props) => {
    const { transactionId, data } = props ?? {};

    return transactionSubmit(transactionId, data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type TransactionSubmitMutationResult = NonNullable<
  Awaited<ReturnType<typeof transactionSubmit>>
>;
export type TransactionSubmitMutationBody = SubmitRequestDto;
export type TransactionSubmitMutationError = unknown;

/**
 * @summary Submit transaction
 */
export const useTransactionSubmit = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionSubmit>>,
    TError,
    { transactionId: string; data: SubmitRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useTransactionSubmitMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Submit a hash of an already broadcasted transaction
 * @summary Submit transaction hash
 */
export const transactionSubmitHash = (
  transactionId: string,
  submitHashRequestDto: SubmitHashRequestDto,
) => {
  return api<void>({
    url: `/v1/transaction/${transactionId}/submit_hash`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: submitHashRequestDto,
  });
};

export const useTransactionSubmitHashMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionSubmitHash>>,
    TError,
    { transactionId: string; data: SubmitHashRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof transactionSubmitHash>>,
  TError,
  { transactionId: string; data: SubmitHashRequestDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transactionSubmitHash>>,
    { transactionId: string; data: SubmitHashRequestDto }
  > = (props) => {
    const { transactionId, data } = props ?? {};

    return transactionSubmitHash(transactionId, data);
  };

  const customOptions = customQueryOptions({ ...mutationOptions, mutationFn });

  return customOptions;
};

export type TransactionSubmitHashMutationResult = NonNullable<
  Awaited<ReturnType<typeof transactionSubmitHash>>
>;
export type TransactionSubmitHashMutationBody = SubmitHashRequestDto;
export type TransactionSubmitHashMutationError = unknown;

/**
 * @summary Submit transaction hash
 */
export const useTransactionSubmitHash = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transactionSubmitHash>>,
    TError,
    { transactionId: string; data: SubmitHashRequestDto },
    TContext
  >;
}) => {
  const mutationOptions = useTransactionSubmitHashMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns the transaction status given a transaction id
 * @summary Get transaction status
 */
export const transactionGetTransactionStatusFromId = (
  transactionId: string,
  signal?: AbortSignal,
) => {
  return api<TransactionStatusResponseDto>({
    url: `/v1/transaction/${transactionId}/status`,
    method: 'get',
    signal,
  });
};

export const getTransactionGetTransactionStatusFromIdQueryKey = (
  transactionId: string,
) => [`/v1/transaction/${transactionId}/status`] as const;

export const useTransactionGetTransactionStatusFromIdQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,
  TError = unknown,
>(
  transactionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTransactionGetTransactionStatusFromIdQueryKey(transactionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>
  > = ({ signal }) =>
    transactionGetTransactionStatusFromId(transactionId, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type TransactionGetTransactionStatusFromIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>
>;
export type TransactionGetTransactionStatusFromIdQueryError = unknown;

/**
 * @summary Get transaction status
 */
export const useTransactionGetTransactionStatusFromId = <
  TData = Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,
  TError = unknown,
>(
  transactionId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetTransactionStatusFromId>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTransactionGetTransactionStatusFromIdQueryOptions(
    transactionId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the current gas parameters for a network
 * @summary Get current gas parameters
 */
export const transactionGetGasForNetwork = (
  network: string,
  signal?: AbortSignal,
) => {
  return api<GasForNetworkResponseDto>({
    url: `/v1/transaction/gas/${network}`,
    method: 'get',
    signal,
  });
};

export const getTransactionGetGasForNetworkQueryKey = (network: string) =>
  [`/v1/transaction/gas/${network}`] as const;

export const useTransactionGetGasForNetworkQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionGetGasForNetwork>>,
  TError = unknown,
>(
  network: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetGasForNetwork>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof transactionGetGasForNetwork>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTransactionGetGasForNetworkQueryKey(network);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionGetGasForNetwork>>
  > = ({ signal }) => transactionGetGasForNetwork(network, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type TransactionGetGasForNetworkQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionGetGasForNetwork>>
>;
export type TransactionGetGasForNetworkQueryError = unknown;

/**
 * @summary Get current gas parameters
 */
export const useTransactionGetGasForNetwork = <
  TData = Awaited<ReturnType<typeof transactionGetGasForNetwork>>,
  TError = unknown,
>(
  network: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof transactionGetGasForNetwork>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTransactionGetGasForNetworkQueryOptions(
    network,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the token prices for a specific list of tokens
 * @summary Get token prices
 */
export const tokenGetTokenPrices = (priceRequestDto: PriceRequestDto) => {
  return api<PriceResponseDto>({
    url: `/v1/token/prices`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: priceRequestDto,
  });
};

export const getTokenGetTokenPricesQueryKey = (
  priceRequestDto: PriceRequestDto,
) => [`/v1/token/prices`, priceRequestDto] as const;

export const useTokenGetTokenPricesQueryOptions = <
  TData = Awaited<ReturnType<typeof tokenGetTokenPrices>>,
  TError = unknown,
>(
  priceRequestDto: PriceRequestDto,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tokenGetTokenPrices>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof tokenGetTokenPrices>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTokenGetTokenPricesQueryKey(priceRequestDto);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokenGetTokenPrices>>
  > = () => tokenGetTokenPrices(priceRequestDto);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type TokenGetTokenPricesQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokenGetTokenPrices>>
>;
export type TokenGetTokenPricesQueryError = unknown;

/**
 * @summary Get token prices
 */
export const useTokenGetTokenPrices = <
  TData = Awaited<ReturnType<typeof tokenGetTokenPrices>>,
  TError = unknown,
>(
  priceRequestDto: PriceRequestDto,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tokenGetTokenPrices>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokenGetTokenPricesQueryOptions(
    priceRequestDto,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the balances for specific addresses and token addresses
 * @summary Get token balances
 */
export const tokenGetTokenBalances = (
  balancesRequestDto: BalancesRequestDto,
) => {
  return api<BalanceResponseDto[]>({
    url: `/v1/token/balances`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: balancesRequestDto,
  });
};

export const getTokenGetTokenBalancesQueryKey = (
  balancesRequestDto: BalancesRequestDto,
) => [`/v1/token/balances`, balancesRequestDto] as const;

export const useTokenGetTokenBalancesQueryOptions = <
  TData = Awaited<ReturnType<typeof tokenGetTokenBalances>>,
  TError = unknown,
>(
  balancesRequestDto: BalancesRequestDto,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tokenGetTokenBalances>>,
      TError,
      TData
    >;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof tokenGetTokenBalances>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTokenGetTokenBalancesQueryKey(balancesRequestDto);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokenGetTokenBalances>>
  > = () => tokenGetTokenBalances(balancesRequestDto);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions;
};

export type TokenGetTokenBalancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokenGetTokenBalances>>
>;
export type TokenGetTokenBalancesQueryError = unknown;

/**
 * @summary Get token balances
 */
export const useTokenGetTokenBalances = <
  TData = Awaited<ReturnType<typeof tokenGetTokenBalances>>,
  TError = unknown,
>(
  balancesRequestDto: BalancesRequestDto,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof tokenGetTokenBalances>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useTokenGetTokenBalancesQueryOptions(
    balancesRequestDto,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
